"use strict";(globalThis.webpackChunkhumanoid_robotics=globalThis.webpackChunkhumanoid_robotics||[]).push([[86],{2671:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"modules/ros2/chapter3","title":"Chapter 3: Building the Robot Body in URDF","description":"What URDF is and Why Humanoid Robots Need It","source":"@site/docs/modules/01-ros2/03-chapter3.md","sourceDirName":"modules/01-ros2","slug":"/modules/ros2/chapter3","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/modules/ros2/chapter3","draft":false,"unlisted":false,"editUrl":"https://github.com/spect-kit-plus/Hakathon_01/tree/main/Humanoid_Robotics/docs/modules/01-ros2/03-chapter3.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Controlling Humanoids with rclpy","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/modules/ros2/chapter2"},"next":{"title":"Module 2: The Digital Twin (Gazebo & Unity)","permalink":"/Physical-AI-Humanoid-Robotics-Textbook/docs/modules/simulation/"}}');var o=n(4848),t=n(8453);const s={},l="Chapter 3: Building the Robot Body in URDF",a={},c=[{value:"What URDF is and Why Humanoid Robots Need It",id:"what-urdf-is-and-why-humanoid-robots-need-it",level:2},{value:"Links, Joints, and Kinematic Chains",id:"links-joints-and-kinematic-chains",level:2},{value:"The <code>&lt;link&gt;</code> Element: Rigid Bodies",id:"the-link-element-rigid-bodies",level:3},{value:"The <code>&lt;joint&gt;</code> Element: Connections Between Links",id:"the-joint-element-connections-between-links",level:3},{value:"Kinematic Chains",id:"kinematic-chains",level:3},{value:"Creating a Basic Humanoid URDF Model",id:"creating-a-basic-humanoid-urdf-model",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"chapter-3-building-the-robot-body-in-urdf",children:"Chapter 3: Building the Robot Body in URDF"})}),"\n",(0,o.jsx)(i.h2,{id:"what-urdf-is-and-why-humanoid-robots-need-it",children:"What URDF is and Why Humanoid Robots Need It"}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.strong,{children:"Unified Robot Description Format (URDF)"})," is an XML file format used in ROS to describe all elements of a robot. It's a fundamental tool for any robot developer, especially for complex systems like humanoids. A URDF file completely specifies the robot's:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Kinematic and Dynamic Properties"}),": Describes the robot's structure, including its links (rigid bodies) and joints (connections between links). It also defines inertial properties (mass, inertia matrix) for each link."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Visual Properties"}),": Defines the visual appearance of each link, including its 3D mesh model, color, and texture. This is used for rendering the robot in simulators (like Gazebo) or visualization tools (like RViz)."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Collision Properties"}),": Defines simplified geometric shapes used for collision detection in simulations. These are often simpler than visual meshes to speed up collision calculations."]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"For humanoid robots, URDF is indispensable because:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Complexity"}),": Humanoids have many links and joints (legs, arms, torso, head), making a detailed, systematic description essential."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Simulation"}),": URDF files are directly used by physics simulators (e.g., Gazebo) to model the robot's physical behavior."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Visualization"}),": Tools like RViz use URDF to display the robot's structure and its current state (e.g., joint angles)."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Kinematics/Dynamics Libraries"}),": Software packages for inverse kinematics or dynamics calculations parse URDF to understand the robot's structure."]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"links-joints-and-kinematic-chains",children:"Links, Joints, and Kinematic Chains"}),"\n",(0,o.jsxs)(i.p,{children:["A URDF model is built up from two primary elements: ",(0,o.jsx)(i.code,{children:"<link>"})," and ",(0,o.jsx)(i.code,{children:"<joint>"}),"."]}),"\n",(0,o.jsxs)(i.h3,{id:"the-link-element-rigid-bodies",children:["The ",(0,o.jsx)(i.code,{children:"<link>"})," Element: Rigid Bodies"]}),"\n",(0,o.jsxs)(i.p,{children:["A ",(0,o.jsx)(i.code,{children:"<link>"})," element describes a rigid body part of the robot. This could be a robot's torso, an upper arm, a thigh, or a foot. Each link has:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Inertial Properties"}),": Defined by the ",(0,o.jsx)(i.code,{children:"<inertial>"})," tag, including ",(0,o.jsx)(i.code,{children:"mass"})," and the ",(0,o.jsx)(i.code,{children:"inertia"})," matrix. These are crucial for accurate physics simulation."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Visual Properties"}),": Defined by the ",(0,o.jsx)(i.code,{children:"<visual>"})," tag, specifying the geometry (mesh, box, cylinder, sphere) and material (color, texture) of the link."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Collision Properties"}),": Defined by the ",(0,o.jsx)(i.code,{children:"<collision>"})," tag, specifying the geometry used for collision detection. This is often a simplified shape of the visual."]}),"\n"]}),"\n",(0,o.jsxs)(i.h3,{id:"the-joint-element-connections-between-links",children:["The ",(0,o.jsx)(i.code,{children:"<joint>"})," Element: Connections Between Links"]}),"\n",(0,o.jsxs)(i.p,{children:["A ",(0,o.jsx)(i.code,{children:"<joint>"})," element describes the kinematic and dynamic properties of the connection between two links. Joints define how links can move relative to each other. Key attributes include:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"name"})}),": A unique identifier for the joint."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"type"})}),": Specifies the joint's movement capabilities (e.g., ",(0,o.jsx)(i.code,{children:"revolute"})," for a rotating joint like a hinge, ",(0,o.jsx)(i.code,{children:"prismatic"})," for a sliding joint, ",(0,o.jsx)(i.code,{children:"fixed"})," for a rigid connection)."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"parent"})}),": The name of the link closer to the robot's base or origin."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"child"})}),": The name of the link further away from the robot's base."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"origin"})}),": Defines the joint's position and orientation relative to the parent link."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"axis"})}),": For revolute and prismatic joints, specifies the axis of rotation or translation."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"limit"})}),": Defines the joint's movement range (lower/upper limits), velocity, and effort limits."]}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"kinematic-chains",children:"Kinematic Chains"}),"\n",(0,o.jsxs)(i.p,{children:["A series of links connected by joints forms a ",(0,o.jsx)(i.strong,{children:"kinematic chain"}),". For humanoids, you'll have multiple chains: one for each leg, one for each arm, one for the torso/head, all branching from a central base link (e.g., the torso or hip)."]}),"\n",(0,o.jsx)(i.h2,{id:"creating-a-basic-humanoid-urdf-model",children:"Creating a Basic Humanoid URDF Model"}),"\n",(0,o.jsxs)(i.p,{children:["Let's create a very simple URDF model for a two-legged robot. This will demonstrate the basic structure of links and joints. This model will be saved as ",(0,o.jsx)(i.code,{children:"Humanoid_Robotics/simulations/module-1/simple_humanoid.urdf"}),"."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot name="simple_humanoid">\r\n\r\n  \x3c!-- Base Link: Torso --\x3e\r\n  <link name="torso">\r\n    <visual>\r\n      <geometry><box size="0.2 0.1 0.3"/></geometry>\r\n      <material name="blue"><color rgba="0 0 1 1"/></material>\r\n    </visual>\r\n    <collision>\r\n      <geometry><box size="0.2 0.1 0.3"/></geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="5.0"/>\r\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- Left Leg --\x3e\r\n  <link name="left_thigh">\r\n    <visual>\r\n      <geometry><box size="0.05 0.05 0.2"/></geometry>\r\n      <material name="green"><color rgba="0 1 0 1"/></material>\r\n    </visual>\r\n    <collision>\r\n      <geometry><box size="0.05 0.05 0.2"/></geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="1.0"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n  </link>\r\n  <joint name="torso_to_left_thigh" type="revolute">\r\n    <parent link="torso"/>\r\n    <child link="left_thigh"/>\r\n    <origin xyz="0 0.075 -0.15" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="10"/>\r\n  </joint>\r\n\r\n  <link name="left_shin">\r\n    <visual>\r\n      <geometry><box size="0.05 0.05 0.2"/></geometry>\r\n      <material name="green"/>\r\n    </visual>\r\n    <collision>\r\n      <geometry><box size="0.05 0.05 0.2"/></geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="1.0"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n  </link>\r\n  <joint name="left_thigh_to_left_shin" type="revolute">\r\n    <parent link="left_thigh"/>\r\n    <child link="left_shin"/>\r\n    <origin xyz="0 0 -0.2" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="-1.57" upper="0" effort="100" velocity="10"/>\r\n  </joint>\r\n\r\n  <link name="left_foot">\r\n    <visual>\r\n      <geometry><box size="0.07 0.05 0.03"/></geometry>\r\n      <material name="green"/>\r\n    </visual>\r\n    <collision>\r\n      <geometry><box size="0.07 0.05 0.03"/></geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="0.5"/>\r\n      <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.005"/>\r\n    </inertial>\r\n  </link>\r\n  <joint name="left_shin_to_left_foot" type="revolute">\r\n    <parent link="left_shin"/>\r\n    <child link="left_foot"/>\r\n    <origin xyz="0 0 -0.2" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="-0.785" upper="0.785" effort="100" velocity="10"/>\r\n  </joint>\r\n\r\n  \x3c!-- Right Leg (similar structure, just mirrored in Y) --\x3e\r\n  <link name="right_thigh">\r\n    <visual>\r\n      <geometry><box size="0.05 0.05 0.2"/></geometry>\r\n      <material name="green"/>\r\n    </visual>\r\n    <collision>\r\n      <geometry><box size="0.05 0.05 0.2"/></geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="1.0"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n  </link>\r\n  <joint name="torso_to_right_thigh" type="revolute">\r\n    <parent link="torso"/>\r\n    <child link="right_thigh"/>\r\n    <origin xyz="0 -0.075 -0.15" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="10"/>\r\n  </joint>\r\n\r\n  <link name="right_shin">\r\n    <visual>\r\n      <geometry><box size="0.05 0.05 0.2"/></geometry>\r\n      <material name="green"/>\r\n    </visual>\r\n    <collision>\r\n      <geometry><box size="0.05 0.05 0.2"/></geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="1.0"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\r\n    </inertial>\r\n  </link>\r\n  <joint name="right_thigh_to_right_shin" type="revolute">\r\n    <parent link="right_thigh"/>\r\n    <child link="right_shin"/>\r\n    <origin xyz="0 0 -0.2" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="-1.57" upper="0" effort="100" velocity="10"/>\r\n  </joint>\r\n\r\n  <link name="right_foot">\r\n    <visual>\r\n      <geometry><box size="0.07 0.05 0.03"/></geometry>\r\n      <material name="green"/>\r\n    </visual>\r\n    <collision>\r\n      <geometry><box size="0.07 0.05 0.03"/></geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="0.5"/>\r\n      <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.005"/>\r\n    </inertial>\r\n  </link>\r\n  <joint name="right_shin_to_right_foot" type="revolute">\r\n    <parent link="right_shin"/>\r\n    <child link="right_foot"/>\r\n    <origin xyz="0 0 -0.2" rpy="0 0 0"/>\r\n    <axis xyz="1 0 0"/>\r\n    <limit lower="-0.785" upper="0.785" effort="100" velocity="10"/>\r\n  </joint>\r\n\r\n  <material name="blue">\r\n    <color rgba="0 0 1 1"/>\r\n  </material>\r\n  <material name="green">\r\n    <color rgba="0 1 0 1"/>\r\n  </material>\r\n\r\n</robot>\n'})})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>l});var r=n(6540);const o={},t=r.createContext(o);function s(e){const i=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(t.Provider,{value:i},e.children)}}}]);