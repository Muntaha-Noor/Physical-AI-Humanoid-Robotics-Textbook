"use strict";(globalThis.webpackChunkhumanoid_robotics=globalThis.webpackChunkhumanoid_robotics||[]).push([[192],{3103:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"modules/simulation/chapter2","title":"Chapter 2: Human-Robot Interaction in Unity","description":"Unity\'s Role in High-Fidelity Rendering and HRI","source":"@site/docs/modules/02-simulation/02-chapter2.md","sourceDirName":"modules/02-simulation","slug":"/modules/simulation/chapter2","permalink":"/Hakathon_01/docs/modules/simulation/chapter2","draft":false,"unlisted":false,"editUrl":"https://github.com/spect-kit-plus/Hakathon_01/tree/main/Humanoid_Robotics/docs/modules/02-simulation/02-chapter2.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: Building the Digital Twin","permalink":"/Hakathon_01/docs/modules/simulation/chapter1"},"next":{"title":"Chapter 3: Simulating Robot Sensors","permalink":"/Hakathon_01/docs/modules/simulation/chapter3"}}');var s=n(4848),r=n(8453);const o={},l="Chapter 2: Human-Robot Interaction in Unity",a={},c=[{value:"Unity&#39;s Role in High-Fidelity Rendering and HRI",id:"unitys-role-in-high-fidelity-rendering-and-hri",level:2},{value:"Setting Up a New Unity Project with HDRP",id:"setting-up-a-new-unity-project-with-hdrp",level:2},{value:"Importing a Humanoid URDF Model",id:"importing-a-humanoid-urdf-model",level:2},{value:"Applying Realistic Lighting with HDRP",id:"applying-realistic-lighting-with-hdrp",level:2},{value:"1. Global Illumination",id:"1-global-illumination",level:3},{value:"2. Light Types",id:"2-light-types",level:3},{value:"3. Exposure Control",id:"3-exposure-control",level:3},{value:"4. Post-Processing Effects",id:"4-post-processing-effects",level:3},{value:"Creating and Applying Physically Based Rendering (PBR) Materials",id:"creating-and-applying-physically-based-rendering-pbr-materials",level:2},{value:"Creating a PBR Material",id:"creating-a-pbr-material",level:3},{value:"Applying a PBR Material",id:"applying-a-pbr-material",level:3}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"chapter-2-human-robot-interaction-in-unity",children:"Chapter 2: Human-Robot Interaction in Unity"})}),"\n",(0,s.jsx)(i.h2,{id:"unitys-role-in-high-fidelity-rendering-and-hri",children:"Unity's Role in High-Fidelity Rendering and HRI"}),"\n",(0,s.jsxs)(i.p,{children:["While Gazebo excels at physics-based simulation and integration with ROS 2, ",(0,s.jsx)(i.strong,{children:"Unity"})," stands out for its high-fidelity rendering capabilities and robust tools for creating interactive 3D environments. For humanoid robotics, Unity becomes invaluable when the focus shifts to:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Human-Robot Interaction (HRI)"}),": Creating realistic scenarios where humans and robots interact, allowing for testing of intuitive interfaces, safety protocols, and collaborative tasks. Unity's rich visual tools and animation systems are perfect for this."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Photorealistic Environments"}),": Generating visually stunning environments that mimic the real world, crucial for training vision-based AI algorithms where the visual details (lighting, shadows, textures) significantly impact model performance."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"User Interface Development"}),": Leveraging Unity's UI toolkit to build sophisticated dashboards and control panels for interacting with simulated robots."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"By combining Unity's strengths with Gazebo's physics and ROS 2 integration, we create a powerful digital twin ecosystem capable of addressing a wider range of research and development challenges in humanoid robotics."}),"\n",(0,s.jsx)(i.h2,{id:"setting-up-a-new-unity-project-with-hdrp",children:"Setting Up a New Unity Project with HDRP"}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.strong,{children:"High Definition Render Pipeline (HDRP)"})," is a pre-built Scriptable Render Pipeline in Unity that allows you to create cutting-edge, high-fidelity graphics. It's ideal for projects that demand photorealism, such as humanoid robot simulations for HRI or realistic synthetic data generation."]}),"\n",(0,s.jsx)(i.p,{children:"Here's a guide to setting up a new Unity project with HDRP:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Launch Unity Hub"}),': Open Unity Hub and click "New Project".']}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Select HDRP Template"}),': From the templates, choose "3D (HDRP)". Give your project a name (e.g., ',(0,s.jsx)(i.code,{children:"HumanoidHRI"}),') and select a location. Click "Create Project".']}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Project Initialization"}),": Unity will take some time to create the project and import all necessary HDRP assets."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Verify HDRP Setup"}),": Once the project opens, go to ",(0,s.jsx)(i.code,{children:"Edit > Project Settings > Graphics"}),'. Ensure "HDRP Global Settings" is assigned. Also, check ',(0,s.jsx)(i.code,{children:"Edit > Project Settings > Quality"}),". You should see quality levels configured for HDRP."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Scene Setup"}),": The default HDRP scene often includes a basic setup with lighting. You can delete existing objects if you want to start from scratch, but keep the ",(0,s.jsx)(i.code,{children:"Volume"})," GameObject which controls global post-processing effects."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Your Unity project is now configured for high-fidelity rendering."}),"\n",(0,s.jsx)(i.h2,{id:"importing-a-humanoid-urdf-model",children:"Importing a Humanoid URDF Model"}),"\n",(0,s.jsxs)(i.p,{children:["To bring your humanoid robot designs (created in URDF, as discussed in Module 1) into Unity, you'll use the ",(0,s.jsx)(i.strong,{children:"Unity Robotics URDF Importer"})," package. This package can parse URDF files and convert them into Unity GameObjects, complete with colliders, rigidbodies, and configurable joints."]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Install URDF Importer Package"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["In your Unity project, go to ",(0,s.jsx)(i.code,{children:"Window > Package Manager"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:["Click the ",(0,s.jsx)(i.code,{children:"+"}),' icon in the top-left corner and choose "Add package from git URL...".']}),"\n",(0,s.jsxs)(i.li,{children:["Enter ",(0,s.jsx)(i.code,{children:"com.unity.robotics.urdf-importer"}),' and click "Add".']}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Import Your URDF"}),":"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["In the Project window, right-click and choose ",(0,s.jsx)(i.code,{children:"Create > Robotics > URDF Robot"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:["Locate your humanoid URDF file (e.g., ",(0,s.jsx)(i.code,{children:"simulations/module-1/robot.urdf"}),") and select it."]}),"\n",(0,s.jsx)(i.li,{children:"The importer will create a prefab of your robot in the Project window. Drag this prefab into your scene hierarchy."}),"\n",(0,s.jsx)(i.li,{children:"You may need to adjust the robot's position and rotation to place it correctly in your scene."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Your humanoid robot model is now part of your Unity scene, ready for interaction and rendering."}),"\n",(0,s.jsx)(i.h2,{id:"applying-realistic-lighting-with-hdrp",children:"Applying Realistic Lighting with HDRP"}),"\n",(0,s.jsx)(i.p,{children:"Realistic lighting is crucial for creating photorealistic environments and accurate vision-based sensor simulation. HDRP offers a rich set of tools to achieve this."}),"\n",(0,s.jsx)(i.h3,{id:"1-global-illumination",children:"1. Global Illumination"}),"\n",(0,s.jsx)(i.p,{children:"Global Illumination (GI) simulates how light bounces off surfaces, creating more realistic indirect lighting."}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Baked GI"}),": For static scenes, pre-calculate light bounces for performance. Go to ",(0,s.jsx)(i.code,{children:"Window > Rendering > Lighting"}),", then ",(0,s.jsx)(i.code,{children:"Generate Lighting"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Realtime GI"}),": For dynamic scenes, HDRP supports real-time GI with limitations."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"2-light-types",children:"2. Light Types"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Directional Light"}),": Simulates light from a distant source (like the sun). Adjust its rotation to change the time of day and shadow direction."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Point Light"}),": Emits light in all directions from a single point (e.g., a bare lightbulb)."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Spot Light"}),": Emits light in a cone shape (e.g., a flashlight)."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Area Light"}),": Emits light from a 2D surface, useful for soft, diffused lighting."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"3-exposure-control",children:"3. Exposure Control"}),"\n",(0,s.jsxs)(i.p,{children:["HDRP uses physical lighting units, so ",(0,s.jsx)(i.strong,{children:"Exposure"})," is critical to balance the scene's brightness. You can control this via the ",(0,s.jsx)(i.code,{children:"Exposure"})," volume override, either automatically or manually."]}),"\n",(0,s.jsx)(i.h3,{id:"4-post-processing-effects",children:"4. Post-Processing Effects"}),"\n",(0,s.jsx)(i.p,{children:"HDRP comes with a suite of post-processing effects that can dramatically enhance realism:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Bloom"}),": Creates a halo around bright areas."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Vignette"}),": Darkens the edges of the image."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Color Grading"}),": Adjusts the overall color balance, contrast, and saturation."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Screen Space Reflections (SSR)"}),": Simulates reflections on glossy surfaces."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Ambient Occlusion (SSAO)"}),": Adds subtle shadows where objects are close together."]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["To add these, select your ",(0,s.jsx)(i.code,{children:"Global Volume"}),' in the Hierarchy, then in the Inspector, click "Add Override" and choose the desired effect.']}),"\n",(0,s.jsx)(i.h2,{id:"creating-and-applying-physically-based-rendering-pbr-materials",children:"Creating and Applying Physically Based Rendering (PBR) Materials"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.strong,{children:"Physically Based Rendering (PBR)"})," materials simulate how light interacts with surfaces in a way that closely matches real-world physics. This makes objects look much more realistic, which is vital for photorealistic rendering in HRI and synthetic data generation."]}),"\n",(0,s.jsx)(i.p,{children:"PBR materials typically use several textures to define a surface's properties:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Albedo Map (Base Color)"}),": Defines the base color of the surface."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Normal Map"}),": Adds surface detail by faking bumps and dents without adding actual geometry."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Metallic Map"}),": Defines which parts of the surface are metallic and which are dielectric (non-metallic)."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Smoothness Map (Roughness/Glossiness)"}),": Defines how rough or smooth the surface is, affecting how light scatters or reflects."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Ambient Occlusion Map (AO)"}),": Simulates soft shadows where objects are close together, adding depth."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"creating-a-pbr-material",children:"Creating a PBR Material"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"In the Project window"}),", navigate to a suitable folder (e.g., ",(0,s.jsx)(i.code,{children:"Assets/Materials"}),")."]}),"\n",(0,s.jsx)(i.li,{children:"**Right-click > Create > Material`."}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"In the Inspector window"}),", change the ",(0,s.jsx)(i.code,{children:"Shader"})," dropdown to ",(0,s.jsx)(i.code,{children:"HDRP/Lit"}),". This is the standard PBR shader for HDRP."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Assign Textures"}),": Drag and drop your texture maps (Albedo, Normal, Metallic, Smoothness, AO) into their respective slots in the Material Inspector."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Adjust Properties"}),": Fine-tune properties like ",(0,s.jsx)(i.code,{children:"Metallic"})," and ",(0,s.jsx)(i.code,{children:"Smoothness"})," sliders if you don't have dedicated maps, or to enhance the material."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"applying-a-pbr-material",children:"Applying a PBR Material"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Select the 3D Object"})," in your scene (e.g., your humanoid robot's parts, the ground plane)."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"In the Inspector window"}),", find the ",(0,s.jsx)(i.code,{children:"Mesh Renderer"})," component."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Drag and Drop"}),": Drag your newly created PBR material from the Project window onto the ",(0,s.jsx)(i.code,{children:"Material"})," slot in the ",(0,s.jsx)(i.code,{children:"Mesh Renderer"})," component."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"By applying PBR materials, you significantly enhance the visual realism of your simulated environment, making it more effective for HRI studies and visual AI training."}),"\n",(0,s.jsx)(i.p,{children:"This concludes our chapter on using Unity for high-fidelity rendering and human-robot interaction."})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>l});var t=n(6540);const s={},r=t.createContext(s);function o(e){const i=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);