# باب 1: روبوٹک اعصابی نظام کے طور پر ROS 2 کو سمجھنا

## ہیومنائڈ روبوٹکس میں مڈل ویئر کیا کرتا ہے

ہیومنائڈ روبوٹکس کی پیچیدہ دنیا میں، مختلف اجزاء — سینسرز، ایکچویٹرز، پرسیپشن، پلاننگ، اور کنٹرول کے لیے الگورتھم — کو بغیر کسی رکاوٹ کے بات چیت کرنے کی ضرورت ہے۔ یہ وہ جگہ ہے جہاں **مڈل ویئر** ایک اہم کردار ادا کرتا ہے۔ مڈل ویئر ایک سافٹ ویئر پرت کے طور پر کام کرتا ہے جو روبوٹک نظام کے تقسیم شدہ اجزاء کے درمیان مواصلات اور ڈیٹا کے تبادلے میں سہولت فراہم کرتا ہے۔ یہ نچلی سطح کی نیٹ ورکنگ، انٹر-پروسیس کمیونیکیشن، اور ہارڈویئر انٹرفیس کی پیچیدگیوں کو دور کرتا ہے، جس سے ڈویلپرز روبوٹ کی فعالیت پر توجہ مرکوز کر سکتے ہیں۔

ہیومنائڈ روبوٹس کے لیے، مڈل ویئر "اعصابی نظام" ہے جو "دماغ" (AI الگورتھم) کو "جسم" (موٹرز، سینسرز) سے جوڑتا ہے۔ یہ قابل بناتا ہے:

*   **ماڈیولریٹی**: روبوٹ کے سافٹ ویئر کے مختلف حصوں کو آزادانہ طور پر تیار اور چلایا جا سکتا ہے۔
*   **اسکیل ایبلٹی**: آسانی سے نئے سینسرز، ایکچویٹرز، یا پروسیسنگ یونٹس شامل کریں۔
*   **لچک**: پورے نظام کو دوبارہ آرکیٹیکٹ کیے بغیر اجزاء کو تبدیل کریں۔
*   **ریئل ٹائم کمیونیکیشن**: اہم کنٹرول اور سینسر ڈیٹا کی بروقت ترسیل کو یقینی بناتا ہے۔

**ROS 2 (روبوٹ آپریٹنگ سسٹم 2)** روبوٹکس کی ترقی کے لیے ڈی فیکٹو معیاری مڈل ویئر ہے۔ یہ روبوٹ سافٹ ویئر لکھنے کے لیے ایک لچکدار فریم ورک فراہم کرتا ہے، جو ٹولز، لائبریریوں، اور کنونشنز کا ایک مجموعہ پیش کرتا ہے جو پیچیدہ روبوٹک ایپلی کیشنز کی تخلیق کو آسان بناتا ہے۔

## ROS 2 نوڈس، ٹاپکس، سروسز، اور ایگزیکیوشن گراف

ROS 2 روبوٹ کے سافٹ ویئر کو باہم مربوط اجزاء میں منظم کرتا ہے۔ ان بنیادی تصورات کو سمجھنا کسی بھی ROS 2 پر مبنی روبوٹک نظام کی تعمیر کے لیے بنیادی ہے۔

### نوڈس: کمپیوٹیشنل پروسیسز

ایک **نوڈ** ایک قابل عمل عمل ہے جو کمپیوٹیشن انجام دیتا ہے۔ ہیومنائڈ روبوٹ میں، ہر فنکشنل یونٹ، جیسے "ہیڈ کیمرہ ڈرائیور"، "بائیں بازو کا کنٹرولر"، "پاتھ پلاننگ الگورتھم"، یا "وائس کمانڈ انٹرپریٹر"، کو ایک علیحدہ ROS 2 نوڈ کے طور پر لاگو کیا جا سکتا ہے۔ نوڈس روبوٹ کے مجموعی مشن کو حاصل کرنے کے لیے ایک دوسرے کے ساتھ بات چیت کرتے ہیں۔

*   **مثال**: نوڈس کو اعصابی نظام میں انفرادی اعضاء کے طور پر سوچیں، ہر ایک کا ایک مخصوص کام ہے۔

### ٹاپکس: ڈیٹا اسٹریمز کے لیے میسج بس

**ٹاپکس** نامی بسیں ہیں جن پر نوڈس غیر مطابقت پذیر طریقے سے پیغامات کا تبادلہ کرتے ہیں۔ جب کوئی نوڈ ڈیٹا (جیسے سینسر ریڈنگز، جوائنٹ اسٹیٹس، پروسیس شدہ تصاویر) کا اشتراک کرنا چاہتا ہے، تو وہ ایک ٹاپک پر پیغامات **پبلش** کرتا ہے۔ اس ڈیٹا میں دلچسپی رکھنے والے دوسرے نوڈس اسی ٹاپک کو **سبسکرائب** کرتے ہیں۔ یہ پبلش-سبسکرائب ماڈل ایک سے کئی مواصلات کو قابل بناتا ہے، جس سے نظام انتہائی ڈی کپلڈ ہو جاتا ہے۔

*   **مثال**: ٹاپکس ان اعصاب کی طرح ہیں جو پورے جسم میں حسی معلومات یا کنٹرول سگنل لے جاتے ہیں۔

### سروسز: درخواست/جواب کا طریقہ کار

**سروسز** ایک مطابقت پذیر درخواست/جواب مواصلاتی نمونہ فراہم کرتی ہیں۔ جب کسی نوڈ کو کسی دوسرے نوڈ کے ذریعہ انجام دیے جانے والے مخصوص کمپیوٹیشن یا کارروائی کی ضرورت ہوتی ہے اور فوری نتیجہ کی توقع ہوتی ہے، تو وہ **سروس کی درخواست** کرتا ہے۔ دوسرا نوڈ **سروس سرور** کے طور پر کام کرتا ہے، درخواست پر کارروائی کرتا ہے، اور **سروس کا جواب** واپس بھیجتا ہے۔

*   **مثال**: سروسز اضطراری یا مخصوص احکامات کی طرح ہیں جہاں فوری، وقف شدہ جواب کی توقع کی جاتی ہے۔

### ROS 2 ایگزیکیوشن گراف

**ROS 2 ایگزیکیوشن گراف** چلنے والے نظام میں تمام ROS 2 عناصر (نوڈس، ٹاپکس، سروسز، ایکشنز) اور وہ کس طرح جڑے ہوئے ہیں، کا ایک تصوراتی نمائندگی ہے۔ یہ ڈیٹا اور کنٹرول کے بہاؤ کو تصور کرنے میں مدد کرتا ہے۔

یہاں ایک سادہ ROS 2 ایگزیکیوشن گراف کا ایک تصوراتی خاکہ ہے:

<!-- ![ROS 2 Execution Graph Conceptual Diagram](img/ros2-graph.svg) -->

## ہیومنائڈ روبوٹ کے ذریعے پیغامات کیسے بہتے ہیں

ایک ہیومنائڈ روبوٹ پر غور کریں جو "آگے چلو" کے صوتی حکم کا جواب دے رہا ہے۔ پیغام کا بہاؤ اس طرح نظر آ سکتا ہے:

1.  ایک "وائس ریکگنیشن" نوڈ (نوڈ A) آڈیو ان پٹ پر کارروائی کرتا ہے اور `/human_commands` ٹاپک پر "ٹیکسٹ کمانڈ" پیغام پبلش کرتا ہے۔
2.  ایک "کمانڈ انٹرپریٹر" نوڈ (نوڈ B) `/human_commands` کو سبسکرائب کرتا ہے، "آگے چلو" کو "بیس ویلوسٹی" پیغامات کی ایک سیریز میں ترجمہ کرتا ہے، اور انہیں `/cmd_vel` ٹاپک پر پبلش کرتا ہے۔
3.  ایک "بیس کنٹرولر" نوڈ (نوڈ C) `/cmd_vel` کو سبسکرائب کرتا ہے اور ان ویلوسٹیز کو روبوٹ کے ٹانگوں کے ایکچویٹرز کے لیے نچلی سطح کے موٹر کمانڈز میں ترجمہ کرتا ہے۔
4.  دریں اثنا، ایک "کیمرہ ڈرائیور" نوڈ تصاویر کو `/camera/image_raw` ٹاپک پر پبلش کرتا ہے، اور ایک "پرسیپشن" نوڈ اسے رکاوٹوں کا پتہ لگانے کے لیے سبسکرائب کرتا ہے، ممکنہ طور پر "رکاوٹ رپورٹس" کو کسی دوسرے ٹاپک پر پبلش کرتا ہے۔
5.  اگر "کمانڈ انٹرپریٹر" کو روبوٹ کی موجودہ پوز جاننے کی ضرورت ہے، تو وہ فوری جواب کے لیے "لوکلائزیشن" نوڈ سے سروس کی درخواست کر سکتا ہے۔

## سادہ پبلشر-سبسکرائبر پیٹرنز کا استعمال کرتے ہوئے مثالیں

### پائتھن پبلشر نوڈ (`simple_publisher.py`)

یہ نوڈ `/chatter` ٹاپک پر ایک سادہ "ہیلو ROS 2" پیغام پبلش کرے گا۔

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimplePublisher(Node):
    def __init__(self):
        super().__init__('simple_publisher')
        self.publisher_ = self.create_publisher(String, 'chatter', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'ہیلو ROS 2: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'پبلشنگ: "{msg.data}"')
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    simple_publisher = SimplePublisher()
    rclpy.spin(simple_publisher)
    simple_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### پائتھن سبسکرائبر نوڈ (`simple_subscriber.py`)

یہ نوڈ `/chatter` ٹاپک کو سبسکرائب کرے گا اور موصولہ پیغامات کو پرنٹ کرے گا۔

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimpleSubscriber(Node):
    def __init__(self):
        super().__init__('simple_subscriber')
        self.subscription = self.create_subscription(
            String,
            'chatter',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'میں نے سنا: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    simple_subscriber = SimpleSubscriber()
    rclpy.spin(simple_subscriber)
    simple_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```
ان مثالوں کو چلانے کے لیے:
1.  دو ٹرمینلز کھولیں۔
2.  ہر ٹرمینل میں، `source /opt/ros/humble/setup.bash` (یا آپ کی ROS 2 ماحولیاتی سیٹ اپ فائل)۔
3.  پہلے ٹرمینل میں، پبلشر چلائیں: `python simple_publisher.py`
4.  دوسرے ٹرمینل میں، سبسکرائبر چلائیں: `python simple_subscriber.py`
آپ کو پیغامات پبلش اور موصول ہوتے نظر آئیں گے۔

یہ ROS 2 مڈل ویئر کے بنیادی تصورات کی ہماری کھوج کا اختتام ہے۔