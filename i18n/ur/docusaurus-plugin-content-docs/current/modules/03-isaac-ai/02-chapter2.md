# باب 2: جدید سمیلیشن ماحول اور سینسرز

## 2.1 پیچیدہ مناظر کی تعمیر: پرائمیٹوز سے دنیاؤں تک

جبکہ ایک سادہ زمینی جہاز ایک اچھی شروعات ہے، حقیقی دنیا کی روبوٹکس کو پیچیدہ، بے ترتیب، اور متحرک ماحول کے ساتھ تعامل کی ضرورت ہوتی ہے۔ آئزک سم ایسے مناظر بنانے کے لیے ٹولز کا ایک طاقتور مجموعہ فراہم کرتا ہے۔

**منظر بنانے کے طریقے:**

*   **دستی اسمبلی (ڈیجیٹل سینڈ باکس):** یہ سب سے زیادہ بدیہی طریقہ ہے۔ آپ مواد براؤزر سے اثاثوں کو براہ راست ویو پورٹ میں گھسیٹ کر چھوڑ سکتے ہیں۔ یہ کسی منظر کو تیزی سے پروٹو ٹائپ کرنے یا کسی مخصوص کام کے لیے ایک چھوٹا، کنٹرول شدہ ماحول بنانے کے لیے مثالی ہے۔ آپ ہر شے کو درست طریقے سے پوزیشن اور سمت دینے کے لیے ٹرانسفارم گزموس (ہاٹ کیز: W ترجمہ کے لیے، E گردش کے لیے، R اسکیل کے لیے) استعمال کر سکتے ہیں۔

*   **پروگراممیٹک اسمبلی (آرکیٹیکٹ کا کوڈ):** بڑے پیمانے پر یا طریقہ کار سے تیار کردہ ماحول کے لیے، پائتھن اسکرپٹنگ ہی راستہ ہے۔ یہ مضبوط AI تربیت کے لیے متنوع اور بے ترتیب ماحول بنانے کا مرکز ہے۔ آپ ہزاروں اشیاء کو سپون کرنے، انہیں پیچیدہ ترتیب میں ترتیب دینے، اور یہاں تک کہ پوری عمارتیں یا شہر کے بلاکس بنانے کے لیے اسکرپٹس لکھ سکتے ہیں۔

*   **USD لیئرنگ (تعاونی بلیو پرنٹ):** یونیورسل سین ڈسکرپشن (USD) میں "لیئرنگ" نامی ایک طاقتور خصوصیت ہے۔ اسے 3D مناظر کے لیے غیر تباہ کن ترمیم کے طور پر سوچیں۔ آپ کے پاس جامد ماحول (جیسے، ایک گودام کی عمارت) کے ساتھ ایک بنیادی پرت ہو سکتی ہے، فرنیچر اور پرپس کے ساتھ ایک اور پرت، اور روبوٹ کے ساتھ ایک تیسری پرت۔ یہ سب رن ٹائم پر ایک واحد، مربوط منظر میں مل جاتے ہیں۔ یہ مختلف ٹیموں کو ایک ہی وقت میں منظر کے مختلف پہلوؤں پر کام کرنے کی اجازت دیتا ہے۔ مثال کے طور پر، ایک فنکار روبوٹ کی جگہ کو متاثر کیے بغیر ایک پرت میں روشنی میں ترمیم کر سکتا ہے۔

***
*خاکہ کے لیے پلیس ہولڈر: "USD لیئرنگ کی وضاحت۔" اس خاکہ کو تین الگ الگ پرتیں دکھانی چاہئیں (جیسے، "environment.usd"، "props.usd"، "robot.usd")۔ تیروں کو یہ بتانا چاہیے کہ وہ کیسے بنتے ہیں، جس میں "robot.usd" پرت کسی مخصوص شے کی پوزیشن پر حتمی اوور رائڈ رکھتی ہے، جو ورک فلو کی غیر تباہ کن نوعیت کو واضح کرتی ہے۔ حتمی کمپوزڈ اسٹیج کو تمام عناصر کو ملا کر دکھانا چاہیے۔
***

**مثال: طریقہ کار سے کیوبز کا ایک فیلڈ سپون کرنا**

```python
import omni.usd
from pxr import Gf, UsdGeom
from omni.isaac.core.utils.prims import define_prim
import numpy as np

# موجودہ اسٹیج حاصل کریں
stage = omni.usd.get_context().get_stage()

# ہمارے کیوبز کے فیلڈ کے لیے پیرامیٹرز
num_cubes_x = 10
num_cubes_y = 10
spacing = 2.0
parent_path = "/World/CubeField"

# اسٹیج کو صاف رکھنے کے لیے ایک پیرنٹ Xform بنائیں
define_prim(prim_path=parent_path, prim_type="Xform")

# کیوبز بنانے اور رکھنے کے لیے لوپ
for i in range(num_cubes_x):
    for j in range(num_cubes_y):
        x_pos = (i - num_cubes_x / 2.0) * spacing
        y_pos = (j - num_cubes_y / 2.0) * spacing
        
        # ہر کیوب کے لیے ایک منفرد راستہ بیان کریں
        cube_path = f"{parent_path}/Cube_{i}_{j}"
        cube_prim = define_prim(prim_path=cube_path, prim_type="Cube")
        
        # پوزیشن سیٹ کریں اور ایک بے ترتیب رنگ شامل کریں
        UsdGeom.Xformable(cube_prim).AddTranslateOp().Set(Gf.Vec3d(x_pos, y_pos, 0.5))
        display_color = UsdGeom.Mesh(cube_prim).CreateDisplayColorAttr()
        display_color.Set([Gf.Vec3f(np.random.rand(), np.random.rand(), np.random.rand())])

print(f"{num_cubes_x * num_cubes_y} کیوبز کا ایک فیلڈ بنایا گیا۔")
```

## 2.2 حواس کی نقالی: اپنے روبوٹ کو آنکھیں اور کان دینا

ایک روبوٹ اتنا ہی اچھا ہے جتنا اس کے سینسرز۔ درست سینسر سمیلیشن ایک اعلیٰ مخلص سمیلیٹر کی سب سے اہم خصوصیات میں سے ایک ہے۔

**عام سینسرز پر ایک گہری نظر:**

*   **RGB-D کیمرا:** یہ جدید روبوٹکس پرسیپشن کا ورک ہارس ہے۔
    *   **RGB:** ایک معیاری رنگین تصویر فراہم کرتا ہے، بالکل ایک باقاعدہ کیمرے کی طرح۔ آبجیکٹ کا پتہ لگانے، درجہ بندی، اور ٹریکنگ کے لیے استعمال ہوتا ہے۔
    *   **ڈیپتھ (D):** ہر پکسل کے لیے، یہ کیمرے سے منظر میں متعلقہ نقطہ تک کا فاصلہ فراہم کرتا ہے۔ یہ ایک "ڈیپتھ میپ" یا "پوائنٹ کلاؤڈ" بناتا ہے، جو 3D تعمیر نو، رکاوٹوں سے بچنے، اور پکڑنے کے لیے ضروری ہے۔
*   **LiDAR (لائٹ ڈیٹیکشن اینڈ رینجنگ):**
    *   **2D LiDAR:** ماحول کا 2D نقشہ بنانے کے لیے ایک ہوائی جہاز میں ایک ہی لیزر بیم کو جھاڑتا ہے۔ عام طور پر زمینی روبوٹس میں لوکلائزیشن اور نیویگیشن کے لیے استعمال ہوتا ہے۔
    *   **3D LiDAR:** ماحول کا ایک مکمل 3D پوائنٹ کلاؤڈ بنانے کے لیے متعدد لیزر بیم (یا ایک گھومنے والا آئینہ) استعمال کرتا ہے۔ گہرائی والے کیمرے سے زیادہ وسیع علاقے پر بھرپور 3D معلومات فراہم کرتا ہے۔
*   **IMU (انرشیل میژرمنٹ یونٹ):** روبوٹ کا توازن کا احساس۔ یہ روبوٹ کی سمت اور حرکت کا تخمینہ لگانے کے لیے ایک ایکسلرومیٹر (لکیری ایکسلریشن کی پیمائش کرتا ہے) اور ایک جائروسکوپ (کونیی رفتار کی پیمائش کرتا ہے) کو یکجا کرتا ہے۔ ریاستی تخمینے اور روبوٹ کو مستحکم رکھنے کے لیے اہم ہے۔
*   **رابطہ سینسرز:** سادہ لیکن اہم۔ یہ اس وقت پتہ لگاتے ہیں جب روبوٹ کا کوئی حصہ کسی شے سے رابطہ کرتا ہے۔ انہیں روبوٹ کی انگلیوں پر رکھا جا سکتا ہے تاکہ یہ معلوم ہو سکے کہ اس نے کسی شے کو کامیابی سے پکڑ لیا ہے، یا اس کے بمپرز پر ٹکراؤ کا پتہ لگانے کے لیے۔

**کیمرا شامل کرنا اور ترتیب دینا:**

1.  **پیرنٹ پرائم کو منتخب کریں:** اسٹیج میں، روبوٹ کے اس لنک کو منتخب کریں جہاں آپ کیمرا منسلک کرنا چاہتے ہیں (جیسے، `chassis_link`، `head_link`)۔
2.  **کیمرا بنائیں:** `Create > Camera`۔
3.  **کیمرے کو پیرنٹ کریں:** نئے `Camera` پرائم کو اسٹیج درجہ بندی میں منتخب روبوٹ لنک پر گھسیٹیں۔ یہ یقینی بناتا ہے کہ کیمرا روبوٹ کے ساتھ حرکت کرتا ہے۔
4.  **پوزیشن اور سمت:** کیمرے کے لیے `Property` پینل میں، کیمرے کو صحیح طریقے سے پوزیشن اور مقصد دینے کے لیے `Transform` اقدار کو ایڈجسٹ کریں۔
5.  **کیمرا پراپرٹیز کو ترتیب دیں:** `Property` پینل میں، آپ حقیقی دنیا کے کیمرے کی نقل کرنے کے لیے کیمرے کی ترتیبات جیسے `Focal Length`، `Focus Distance`، اور `Clipping Range` کو بھی ایڈجسٹ کر سکتے ہیں۔

***
*اسکرین شاٹ کے لیے پلیس ہولڈر: "کیمرا پراپرٹیز پینل"۔ اس اسکرین شاٹ کو منتخب کیمرا پرائم کے لیے `Property` پینل دکھانا چاہیے، جس میں کلیدی ترتیبات جیسے `Focal Length`، `Clipping Range`، اور `Transform` اقدار کی طرف اشارہ کرنے والے تشریحات ہوں۔
***

## 2.3 ریپلیکیٹر کے ساتھ مصنوعی ڈیٹا جنریشن: AI فیول فیکٹری

ریپلیکیٹر مصنوعی ڈیٹا بنانے کے لیے آئزک سم کا طاقتور انجن ہے۔ یہ صرف تصاویر لینے کے بارے میں نہیں ہے؛ یہ بڑے پیمانے پر بالکل لیبل والے، متنوع ڈیٹاسیٹ بنانے کے بارے میں ہے۔

**ڈومین رینڈمائزیشن کی طاقت:**

"حقیقت کا فرق" سمیلیشن اور حقیقی دنیا کے درمیان فرق ہے۔ اگر آپ کسی ماڈل کو صرف ایک کامل، صاف سمیلیشن پر تربیت دیتے ہیں، تو یہ ممکنہ طور پر گندی، غیر متوقع حقیقی دنیا میں ناکام ہو جائے گا۔ ڈومین رینڈمائزیشن (DR) سمیلیشن میں تغیرات متعارف کروا کر اس فرق کو پر کرنے میں مدد کرتا ہے۔

**کلیدی DR پیرامیٹرز:**

*   **روشنی:** روشنیوں کا رنگ، شدت، سمت، اور پوزیشن کو بے ترتیب بنائیں۔ روشنیوں کو تصادفی طور پر شامل کریں یا ہٹا دیں۔
*   **بناوٹ:** اشیاء کی بناوٹ کو تصادفی طور پر تبدیل کریں (جیسے، ایک لکڑی کی میز دھات کی میز بن سکتی ہے)۔
*   **آبجیکٹ پوز:** منظر میں اشیاء کی پوزیشن، گردش، اور اسکیل کو بے ترتیب بنائیں۔
*   **کیمرا:** کیمرے کی پوزیشن، سمت، اور فوکل لینتھ جیسے اندرونی پیرامیٹرز کو بے ترتیب بنائیں۔

**مثال: بے ترتیب ڈیٹا کے لیے ایک مکمل ریپلیکیٹر اسکرپٹ**

یہ اسکرپٹ ایک ٹورس رکھے گا، اس کا رنگ اور پوزیشن بے ترتیب بنائے گا، اور اس کے لیے ایک RGB تصویر اور باؤنڈنگ باکس ڈیٹا کیپچر کرے گا۔

```python
import omni.replicator.core as rep

# ہماری اشیاء کے لیے راستے بیان کریں
torus_path = "/World/Torus"
camera_path = "/World/Camera"

# ہمارے ریپلیکیٹر گراف کے لیے ایک نئی پرت بنائیں
with rep.new_layer():

    # ایک کیمرا اور ایک ٹورس بنائیں
    camera = rep.create.camera(position=(0, -5, 1))
    torus = rep.create.torus(semantics=[('class', 'torus')])

    # ریپلیکیٹر کو بتائیں کہ کیمرے اور ٹورس میں ترمیم کیسے کریں
    with rep.trigger.on_frame(num_frames=100):
        # ہر فریم میں ٹورس کی پوز اور رنگ کو بے ترتیب بنائیں
        with torus:
            rep.modify.pose(
                position=rep.distribution.uniform((-1, 0.5, -1), (1, 0.5, 1)),
                rotation=rep.distribution.uniform((-180, -180, -180), (180, 180, 180))
            )
            rep.modify.attribute("color", rep.distribution.uniform((0,0,0), (1,1,1)))

        # کیمرے کو ٹورس پر ہدف بنائیں
        with camera:
            rep.modify.look_at(target=torus)
            
    # آؤٹ پٹ کو محفوظ کرنے کے لیے ایک مصنف بنائیں
    writer = rep.WriterRegistry.get("BasicWriter")
    writer.initialize(output_dir="~/replicator_output", rgb=True, bounding_box_2d_tight=True)
    
    # مصنف کو رینڈر پروڈکٹ سے منسلک کریں
    writer.attach([camera])

# اسے چلانے کے لیے: اسکرپٹ ایڈیٹر میں پیسٹ کریں اور چلائیں پر کلک کریں۔
# ڈیٹا آپ کی ہوم ڈائرکٹری میں "replicator_output" نامی فولڈر میں محفوظ ہو جائے گا۔
```

## 2.4 فزکس پر مبنی ہیرا پھیری کا تعارف

یہ وہ جگہ ہے جہاں سمیلیشن واقعی چمکتی ہے: روبوٹ بازو کے اس کے ماحول کے ساتھ پیچیدہ تعاملات کی ماڈلنگ۔

**کلیدی تصورات:**

*   **آرٹیکلیشنز:** جوڑوں کے ذریعے جڑے ہوئے سخت جسموں کا ایک مجموعہ (جیسے، ایک روبوٹ بازو)۔ آئزک سم ان پیچیدہ زنجیروں کی حرکیات کی نقالی کر سکتا ہے۔
*   **جوائنٹ ڈرائیوز:** یہ وہ موٹرز ہیں جو جوڑوں کو کنٹرول کرتی ہیں۔ آپ ہر جوڑ کے لیے ایک ہدف پوزیشن یا رفتار مقرر کر سکتے ہیں، اور ایک PID کنٹرولر اس ہدف تک پہنچنے کے لیے ضروری قوتوں کا اطلاق کرے گا۔
*   **گرپرز:** بازو کا اینڈ ایفیکٹر۔ یہ سادہ دو انگلیوں والے گرپرز یا زیادہ پیچیدہ ہاتھ ہو سکتے ہیں۔ انہیں بھی جوائنٹ ڈرائیوز کے ذریعے کنٹرول کیا جاتا ہے۔

**ایک سادہ ہیرا پھیری کا کام (تصوراتی مراحل):**

1.  **ایک روبوٹ بازو درآمد کریں:** ایک روبوٹ جیسے فرینکا ایمیکا پانڈا (`Isaac/Robots/Franka/franka.usd`) درآمد کریں۔
2.  **ایک شے رکھیں:** ایک کیوب بنائیں اور اسے روبوٹ کی پہنچ میں رکھیں۔
3.  **ایک ہدف بیان کریں:** مقصد روبوٹ کے اینڈ ایفیکٹر کو کیوب کے بالکل اوپر ایک پوزیشن پر منتقل کرنا ہے۔
4.  **انورس کائیمیٹکس (IK):** بازو کو ہدف کی پوزیشن تک پہنچنے کے لیے درکار جوڑوں کے زاویوں کا حساب لگانے کے لیے ایک IK حل کنندہ استعمال کریں۔
5.  **جوائنٹ اہداف مقرر کریں:** بازو کے جوائنٹ ڈرائیوز کی ہدف پوزیشنوں کو IK حل کنندہ کے ذریعہ حساب کردہ زاویوں پر مقرر کریں۔
6.  **پکڑنا:** کیوب کو پکڑنے کے لیے گرپر کے جوڑوں کو بند کریں۔
7.  **مقصد کی طرف بڑھیں:** ایک نیا ہدف مقام بیان کریں اور بازو (اور پکڑے ہوئے کیوب) کو نئی جگہ پر منتقل کرنے کے لیے دوبارہ IK استعمال کریں۔

***
*ویڈیو یا تصاویر کے سلسلے کے لیے پلیس ہولڈر: "فرینکا آرم پک اینڈ پلیس۔" اس سلسلے کو دکھانا چاہیے:
1. فرینکا بازو اپنی ہوم پوزیشن میں ایک میز پر ایک کیوب کے ساتھ۔
2. بازو کیوب کے اوپر ایک پہلے سے پکڑنے کی پوزیشن پر منتقل ہو رہا ہے۔
3. گرپر کیوب پر بند ہو رہا ہے۔
4. بازو کیوب کو اٹھا رہا ہے۔
5. بازو ایک نئی جگہ پر منتقل ہو رہا ہے اور کیوب کو نیچے رکھ رہا ہے۔
***

## 2.5 خلاصہ

اس باب میں، آپ نے پیچیدہ، حقیقت پسندانہ ماحول بنانے کے اصول سیکھنے کے لیے سادہ مناظر سے آگے بڑھے۔ آپ نے کلیدی روبوٹک سینسرز کی نقالی کرنے اور ڈومین رینڈمائزیشن کے ساتھ مصنوعی ڈیٹا بنانے کے لیے طاقتور ریپلیکیٹر API کا استعمال کرنے پر گہری نظر ڈالی۔ آخر میں، آپ کو فزکس پر مبنی ہیرا پھیری کے بنیادی تصورات سے متعارف کرایا گیا۔ اگلے باب میں، آپ یہ سیکھیں گے کہ اس سب کو ROS 2 ایکو سسٹم سے کیسے جوڑا جائے، سمیلیشن اور حقیقی دنیا کے روبوٹکس سافٹ ویئر کے درمیان فرق کو پر کرتے ہوئے۔
